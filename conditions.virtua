;; -*- LISP -*-

(defclass Condition)
(defclass Error (Condition))
(defclass Warning (Condition))
(defclass Restart (Condition))

(defclass Simple-Error (Error)
  (message)
  (:constructor make-simple-error (message)))

(defvar *handlers-frame-option* nothing)

(defclass Handlers-Frame ()
  (parent-option
   handlers-list)
  (:constructor make-handlers-frame (parent-option handlers-list)))

(defclass Handler ()
  (condition-class
   handler-function)
  (:constructor make-handler (condition-class handler-function)))

(defun handler-matches-condition? (handler condition)
  (instance? condition (.condition-class handler)))

(defun call-with-handlers (thunk handlers-list)
  (fluid-let (*handlers-frame-option*
              (just (make-handlers-frame *handlers-frame-option* handlers-list)))
    (thunk)))

(defgeneric signal (condition))

(defmethod signal ((condition Condition))
  (defun signal-frame (frame-option)
    (if-option (frame frame-option)
      (progn
        (when-option (handler (find-if (lambda (h)
                                         (handler-matches-condition? h condition))
                                       (.handlers-list frame)))
          ((.handler-function handler) condition))
        (signal-frame (.parent-option frame)))
      (default-handler condition)))
  (signal-frame *handlers-frame-option*))

(defmethod signal ((message String))
  (signal (make-simple-error message)))

(defun throw (x)
  (signal x)
  (invoke-debugger x))

(defgeneric default-handler (condition))
(defmethod default-handler ((c Condition))
  #void)
(defmethod default-handler ((w Warning))
  (print w))
(defmethod default-handler ((e Error))
  (invoke-debugger e))
(defmethod default-handler ((r Restart))
  (invoke-debugger "unhandled restart"))

(defun invoke-debugger (x) (js-throw x))

;; handler ::= ((Class var) . exprs)
(defmacro handle (expr . handlers) env
  (call-with-handlers (lambda () (eval expr env))
                      (map (lambda (h)
                             (let ((((c v) . exprs) h))
                               (make-handler (eval c env)
                                             (eval (list* lambda (list v) exprs) env))))
                           handlers)))

(defmacro catch (expr . handlers) env
  (block normal-return
    ((block error-return ; note extra evaluation
       (eval (list* handle (list return-from normal-return expr)
                    (map (lambda (h)
                           (let (((cv . exprs) h))
                             (list cv (list return-from error-return
                                            (list* lambda () exprs)))))
                         handlers))
             env)))))
