;; -*- LISP -*-

(provide (Condition
          Error
          Warning
          Restart
          Simple-Error
          catch
          handle
          throw
          signal
          default-handler)

(defclass Condition)
(defclass Error (Condition))
(defclass Warning (Condition))
(defclass Restart (Condition))

(defclass Simple-Error (Error)
  (message)
  (:constructor make-simple-error (message)))

(defvar *handlers-frame-option* nothing)

(defclass Handlers-Frame ()
  (parent-option
   handlers-list)
  (:constructor make-handlers-frame (parent-option handlers-list)))

(defclass Handler ()
  (matcher-function
   handler-function)
  (:constructor make-handler (matcher-function handler-function)))

(defun handler-matches-condition? (handler condition)
  ((.matcher-function handler) condition))

(defun call-with-handlers (thunk handlers-list)
  (fluid-let (*handlers-frame-option*
              (just (make-handlers-frame *handlers-frame-option* handlers-list)))
    (thunk)))

(defgeneric signal-internal (condition))

(defmethod signal-internal ((condition Condition))
  (defun signal-frame (frame-option)
    (if-option (frame frame-option)
      (progn
        (when-option (handler (find-if (lambda (h)
                                         (handler-matches-condition? h condition))
                                       (.handlers-list frame)))
          ((.handler-function handler) condition))
        (signal-frame (.parent-option frame)))
      (default-handler condition)))
  (signal-frame *handlers-frame-option*))

(defmethod signal-internal ((message String))
  (signal-internal (make-simple-error message)))

(defun throw-internal (x)
  (signal-internal x)
  (invoke-debugger x))

(defgeneric default-handler (condition))
(defmethod default-handler ((c Condition))
  #void)
(defmethod default-handler ((w Warning))
  (print w))
(defmethod default-handler ((e Error))
  (invoke-debugger e))
(defmethod default-handler ((r Restart))
  (invoke-debugger "unhandled restart"))

(defun invoke-debugger (x) (js-throw x))

;; handler ::= ((Class var) . exprs)
(defmacro handle (expr . handlers) env
  (call-with-handlers (lambda () (eval expr env))
                      (map (lambda (h)
                             (let ((((c v . ac) . exprs) h))
                               (make-handler (lambda (condition)
                                               (instance? condition (eval c env)))
                                             (eval (list* lambda (list v) exprs) env))))
                           handlers)))

(defmacro catch (expr . handlers) env
  (block normal-return
    ((block error-return ; note extra evaluation
       (eval (list* handle (list return-from normal-return expr)
                    (map (lambda (h)
                           (let (((cv . exprs) h))
                             (list cv (list return-from error-return
                                            (list* lambda () exprs)))))
                         handlers))
             env)))))

(defmacro signal-with-restarts (raiser condition . restarts) env
  (eval (list* catch (list raiser condition) restarts) env))

(defmacro throw condition-and-restarts env
  (apply (wrap signal-with-restarts) (list* throw-internal condition-and-restarts) env))

(defmacro signal condition-and-restarts env
  (apply (wrap signal-with-restarts) (list* signal-internal condition-and-restarts) env))

) ; edivorp
